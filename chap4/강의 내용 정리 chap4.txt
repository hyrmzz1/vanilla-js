#4.0
html에서 form과 그 내부에 input, button 생성하고, js가 처리하도록 해보자
=>querySelector 사용하여 js에 form 및 input, btn 끌고와야 함.

btn 클릭할 때마다 (click 이벤트 적용) 콘솔이나 알림으로 뜨도록 해보자.

input value를 얻기 위해선?
console.dir 사용하여 input 안에 value 라는 property가 있단걸 확인하는게 우선.

#4.1 username의 유효성을 검사하자.
1) username은 반드시 작성되어 있어야 하고
2) 길이 제한도 걸자.

const loginInput = document.querySelector("#login-form input");
const loginButton = document.querySelector("#login-form button");
const username = loginInput.value;	//input에 작성된 값 가져오기

if-else if-else 문을 통해 입력받은 username의 작성유무, 길이 등을 판별하여 alert 등을 표시할 수 있다.
// loginInput.value는 반복적으로 사용되므로 function 내부에서 변수화하자.

String의 길이를 구하는 법? stringName.length

그러나 input의 작성유무, 길이 등은 html에서 자체적으로 required나 maxlength 등을 통해 할 수 있다.
// 위와 같은 input의 유효성 검사를 작동시키기 위해서는 input 이 form tag 내부에 있어야 한다.

form이 submit되면 웹사이트가 새로고침 된다.
"form 안에서 엔터를 누르고 input이 더이상 존재하지 않는다면 자동으로 submit된다."	// lec#4.1 commit 주석 참고
-> btn의 click이 아닌 submit에 신경써보자
-> submit을 막아야 한다!!

#4.2
btn에 대한 click event 말고, login-form 자체에 대해 submit event 발생여부 확인해서 막아버리자!
//submit은 엔터를 누르거나 버튼을 클릭할 때 발생한다.

브라우저의 기본 동작 : 엔터를 누를 때 새로고침을 하고 form을 submit한다.
-> 이렇게 되면 입력받은 input value도 새로고침과 함께 사라짐.
새로고침이 안되도록 하려면?

const loginForm = document.querySelector("#login-form");
const loginInput = document.querySelector("login-form input");

function onLoginSubmit(event){
	event.preventDefault();
	//브라우저의 기본동작을 막아줌
	//기본 동작이란 어떤 function에 대해 브라우저가 기본적으로 수행하는 동작.
	console.log(event);
}//event argument.......... 모든 eventListener의 첫번째 인수는 지금 막 벌어진 일들에 대한 정보.!⭐

loginForm.addEventListener("submit", onLoginSubmit);

#4.3
html에 <a href = "~~">Go</a> tag 이용해 링크 넣기.

기본동작 막아보자.
- form의 기본동작? submit.
- 링크의 기본동작? 클릭시 다른 페이지로 이동하는 것.
* 링크 기본동작 막는 이유? 무엇이, 어디가 클릭됐는지 info 알고 싶을 때가 있으니까.
=> JS가 함수 실행시키는 동시에 해당 함수 첫 인자로 object 넣어준다.

// 이 강의에서 추가하는 코드
const link = document.querySelector("a");	// 링크 찾았다

function handleLinkClick(event){	//JS가 함수 실행 + 해당 함수 첫 인자로 object 넣어줌.
	event.preventDefault();	//브라우저의 기본동작 막아줌.	 -> 클릭해도 해당 링크로 안넘어감.
	console.dir(event);		// 기본동작 막았기 때문에 콘솔창에서 확인 가능함.
	//alert("clicked!");		//클릭시 알림 뜸. ok 누르면 브라우저의 기본동작 실행.
}

link.addEventListener("click", handleLinkClick);

* 정리
addEventListener()안의 함수는 직접이 아닌 브라우저가 실행시키고, 브라우저에서 해당 이벤트에 대한 object(정보)를 가지게 된다.
addEventListener()안 함수에서 object에 대한 자리를 할당해주면 (ex; onLoginSubmit(event), handleLinkClick(event) 에서 괄호 안의 event)
해당 이벤트가 발생시킨 정보들에 대한 object들을 볼 수 있다. -> ex; console.log(event), console.dir(event)
이 때, 해당 이벤트가 가진 기본동작(default)들을 발생시키지 않으려면 (ex; submit 클릭시 새로고침, link click시 다음 페이지로 이동)
preventDefault() 이용하면 된다. -> 이 코드를 함수 맨 위에 작성해야 기본동작 막히고, 아래 코드들 실행됨.

#4.4 getting username
유저가 input에 username을 제출하면 해당 form을 없애보자.
//form은 숨기고 h1은 텍스트가 있을 때만 표시되도록 해보자.

sol 1) html 자체를 없앤다
sol 2) css를 이용해 숨긴다 => hidden이란 classname 더해주기

<style.css>
.hidden{
	display: none;	
	//visibility: hidden; 은 공간은 그대로 두고 보이지 않게 하는 것.
	//display: none; 은 공간까지 사라지면서 안보이게 하는 것.
}

<app.js>
const loginForm = document.querySelector("#login-form");
const loginInput = document.querySelector("login-form input");
const greeting = document.querySelector("#greeting");
const HIDDEN_CLASSNAME = "hidden";	
// 변수명 대문자로 쓰는 경우?
// 1. string만 포함된 변수. string을 저장하고 싶을 때 사용. **이게 일반적 이유! string 오타나면 안되기 때문. 변수명이 오타나면 JS에서 에러 띄워줘 오타 알아차릴 수 있음.
// 2. loginForm, loginInput처럼 중요한 정보를 담지 않았을 때. (중요한 변수 아닐 때)

function onLoginSubmit(event){
	event.preventDefault();	//브라우저의 기본동작을 막아줌
	const username = loginInput.value;	//새로고침 안됨
	loginForm.classList.add(HIDDEN_CLASSNAME);
	console.log(username);	//loginForm 안뜨지만 콘솔엔 뜬다.
	greeting.innerText = "Hello "+username;	//`Hello ${username}` 과 같음. ${} 안에 변수명 들어가면 된다. ``<-백틱 이라고 한다! 백틱으로 전체 감싸주기.
	greeting.classList.remove(HIDDEN_CLASSNAME);
}

loginForm.addEventListener("submit", onLoginSubmit);

<index.html>
<h1 id="greeting" class="hidden"></h1>	//원래 파일에 추가.

#4.5 saving username
입력받은 username을 기억해보자.
브라우저에 무언가를 기억할 수 있게 해주는 API는 local storage!
검사 - application - Local Storage - fille:// 들어가면 볼 수 있음.

Local Storage API method 사용해보자 (in console)	// method(key, value) 형식 사용.
// key-value -> dictionary 자료형. 딕셔너리는 key와 value를 한 쌍으로 갖는 자료형. 키 하나당 값 하나를 가진다. (1:1 대응)
localStorage.setItem("username", "nico")	// username 에 nico라는 값 저장
localStorage.setItem("username", "reem")	// nico 값 사라지고 username의 값 reem으로 바뀜.
localStorage.getItem("username")		// reem. 저장된 값 가져옴
localStorage.removeItem("username")		// 저장된 값 지움

it looks like mini tiny DB!

#4.6 loading username
위 강의에서 
const username = loginInput.value;
localStorage.setItem("username", username);
코드를 통해 input에서 입력받은 값을 username이란 변수에 저장했고,
그 변수를 username이란 key의 value로 저장하였다.

local storage가 비어있다면 (loginInput 입력 X) -> form 보여주면서 앞 강의에서 했던대로 쭉~
local storage에 user 정보가 있다면 (loginInput 입력-> username 有) -> form 숨기고 h1 요소 보여주기

-1) local storage에 user 정보 유무 확인하기
<app.js>
const loginForm = document.querySelector("#login-form");
const loginInput = document.querySelector("login-form input");
const greeting = document.querySelector("#greeting");

const HIDDEN_CLASSNAME = "hidden";
const USERNAME_KEY = "username";	//두번 이상 사용되는 string 무조건 변수화 (실수하면 안되는 string 이니까!!)

function onLoginSubmit(event){
	event.preventDefault();	//브라우저의 기본동작을 막아줌
	const username = loginInput.value;	//새로고침 안됨
	loginForm.classList.add(HIDDEN_CLASSNAME);
	console.log(username);	//loginForm 안뜨지만 콘솔엔 뜬다.
	localStorage.setItem(USERNAME_KEY)
	/*greeting.innerText = "Hello "+username;	//`Hello ${username}` 과 같음. ${} 안에 변수명 들어가면 된다. ``<-백틱 이라고 한다! 백틱으로 전체 감싸주기.
	greeting.classList.remove(HIDDEN_CLASSNAME);*/
	paintGreetings(username);	// 여러줄의 코드가 두번이나 반복되어 사용되므로 함수화.
}

function paintGreetings(){}

loginForm.addEventListener("submit", onLoginSubmit);

const savedUsername = localStorage.getItem(USERNAME_KEY);

//html에서 form이랑 greeting 모두 숨긴 채로 시작하는게 나을듯. =>hidden 넣어주기
if (savedUsername === null){		//JS에선 ==대신 === 사용⭐⭐
	//show the form
	loginForm.classList.remove(HIDDEN_CLASSNAME);
	loginForm.addEventListener("submit", onLoginSubmit);
}else{
	//show the greetings
	/*greeting.innerText = "Hello "+username;
	greeting.classList.remove(HIDDEN_CLASSNAME);*/ //위랑 똑같은 코드이므로 함수로 만들어버리자. =>function paintGreetings(username){} 안에 이 코드 넣어버리자
	paintGreetings(username);
}

새로고침 해도 input 에 작성한 username 저장되기 때문에 form 안뜨고 hello username 이라는 h1 만 뜬다.

#4.7 SUPER recap ; 코드의 로직 되짚어보자.
JS가 없는 상태의 HTML -> login-form과 greeting 모두 hidden 상태. link만 뜬다.
HTML-JS 연결 되었을 때
0) link.addEventListener 통해 링크(<a> tag)가 클릭될 시 onLinkClick 함수 실행됨.
1) localStorage.getItem(USERNAME_KEY) 통해 js가 local storage에서 username 이란 key의 여부 확인
2) if-else문
-> username key가 없다면 -> if문 실행. (2-1)
-> username key가 있다면 -> else문 실행. (2-2)

2-1) savedUsername === null
login-form 의 hidden 클래스를 remove 하기 때문에 login-form 나타남.
loginForm.addEventListener("submit",onLoginSubmit); 코드가 form이 submit되길 기다리고, submit 되는 순간 js가 onLoginSubmit() 호출
2-1-1)
js는 함수를 호출하면서 인자를 주고, 해당 인자에는 event에 관한 정보들이 담겨있음.
그 정보에 있는 기본 작동을 event.preventDefault(); 통해 멈춰준다. -> 브라우저 기본 작동은 새로고침이므로 새로고침 멈춰줌.
2-1-2)
login input에 username 작성 후 submit 눌렀을테니(required 때문에 무조건 작성되어 있어야만 submit 제출됨) 다시 form을 숨긴다.
hidden 클래스 추가하기.
왜냐면 이제 h1(#greeting)만 띄울거니까!
2-1-3)
입력받은 input 값을 변수로 만들고, 해당 변수를 local storage에 "username" key의 value로 추가함.
local storage에 값으로 추가하는 이유? 새로고침 후에도 username 기억하기 위해.
2-1-4)
showGreeting() 함수 실행.
해당 함수는 h1 id="greeting" tag의 hidden 클래스 삭제해 h1이 나타나게 한다.
html에서 h1에 아무것도 작성하지 않았기 때문에 hidden 클래스 삭제해도 아무것도 안뜸.
따라서 JS에서 innerText 작성해야 하는데, 함수에서 받은 인수(=local storage에 저장된 username 키의 값) 여기서 나타내주면 된다.
greeting.classList.remove(HIDDEN_CLASSNAME);
greeting.innerText = `Hello ${name}`;
위 두줄의 코드 순서는 바뀌어도 상관없음. h1 innerText 생긴 후에 hidden 없애서 딱 나타나게 하는거니까!

2-2) savedUsername !=== null
local storage에 이미 username key의 값이 있다면 (로그인 전적 있을시) 로그인할 필요 없이 h1(#greeting)만 나타내면 됨.
login-form과 greeting 둘다 hidden class 추가된 상태니까 greeting에만 hidden class 삭제해줌.
그런데 이는 submit event가 발생했을 때와 같이 나타내면 되는거니까 (입력받은 값 local storage에 저장한 이후. 여긴 이미 저장되있는 상태)
greeting.classList.remove(HIDDEN_CLASSNAME);
greeting.innerText = `Hello ${name}`;
코드를 함수화.